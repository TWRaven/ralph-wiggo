# Ralph Progress Log
Started: Fri Feb 20 20:14:14 CET 2026

## Codebase Patterns
- Go module path: github.com/radvoogh/ralph-wiggo
- CLI entry point: cmd/ralph-wiggo/main.go
- Kong CLI framework: subcommands defined as struct fields on CLI type, with Run(globals *CLI) method
- Use `gb <branch-name>` for branch creation (git-machete), `gsn` for rebase+MR
- Fresh repos need an initial commit before `gb` works
- Embedded files live in `embedded/` package with `go:embed` directive in `embedded/embed.go`
- `internal/prompts` wraps the embedded FS — use `prompts.Get("filename.md")` to read content
- Override embedded files at runtime via `prompts.SetOverride(name, path)` or CLI `--prompt-override name=path`
- Kong `AfterApply()` method on CLI struct runs after flag parsing, before subcommand — used for setup logic
- `internal/claude` package: `Executor` wraps the claude CLI, `RunConfig` holds invocation params, `StreamEvent` models NDJSON output
- `RunStreaming` uses `exec.CommandContext` for cancellation, `bufio.Scanner` for NDJSON parsing, returns `<-chan StreamEvent`
- `RunInteractive` connects stdin/stdout/stderr to the terminal — no -p flag unless cfg.Prompt is set
- `RunJSON` uses `--output-format json` and `--json-schema`, captures stdout into buffer, parses result envelope
- Common args (model, turns, budget, etc.) extracted into `buildCommonArgs` — reused by all three modes

---

## 2026-02-20 - US-001
- Implemented: Go project scaffolding with module init, kong CLI framework with 5 subcommands (run, prd, convert, serve, full) and global flags (--verbose, --model, --max-budget, --max-turns, --work-dir)
- Files changed: go.mod, go.sum, cmd/ralph-wiggo/main.go
- **Learnings for future iterations:**
  - Kong uses struct tags for CLI definition — subcommands are embedded structs with `cmd:""` tag
  - Each subcommand needs a `Run(globals *CLI) error` method
  - `gb` requires at least one commit to exist in the repo
  - Global flags are on the parent CLI struct, automatically available to all subcommands
---

## 2026-02-20 - US-002
- Implemented: Embedded prompt and skill files with go:embed, internal/prompts package with Get and override support, --prompt-override CLI flag
- Files changed: embedded/embed.go, embedded/prompt.md, embedded/prd-skill.md, embedded/ralph-skill.md, internal/prompts/prompts.go, internal/prompts/prompts_test.go, cmd/ralph-wiggo/main.go
- **Learnings for future iterations:**
  - `go:embed` can only embed files relative to the package directory — embedded files must live in or under the Go package that declares the embed directive
  - Solution: put embed.FS export in `embedded/` package, then import from `internal/prompts`
  - Kong `AfterApply()` on CLI struct is the right hook for pre-command setup (override registration)
  - Kong supports `[]string` flags that can be repeated: `--prompt-override a=b --prompt-override c=d`
---

## 2026-02-20 - US-003
- Implemented: Claude CLI executor package (internal/claude) with Executor struct, RunConfig, StreamEvent types, and RunStreaming method for spawning claude with NDJSON streaming output
- Files changed: internal/claude/claude.go
- **Learnings for future iterations:**
  - Claude CLI `--output-format stream-json` emits NDJSON — one JSON object per line with a `type` field
  - Use `exec.CommandContext` for context cancellation of subprocesses
  - `bufio.Scanner` needs a large buffer (10MB) for tool output lines that can be very large
  - Always drain stderr in a separate goroutine to prevent blocking the subprocess
  - `json.RawMessage` is useful for preserving raw event data while also parsing known fields
---

## 2026-02-20 - US-004
- Implemented: RunInteractive and RunJSON methods on Executor, refactored common arg building into buildCommonArgs
- Files changed: internal/claude/claude.go
- **Learnings for future iterations:**
  - Refactored `buildStreamingArgs` into `buildCommonArgs` + mode-specific prefix — keeps all three modes (streaming, interactive, JSON) DRY
  - `RunInteractive` connects os.Stdin/Stdout/Stderr directly — no pipe management needed
  - `RunJSON` captures stdout into `bytes.Buffer`, then parses the `result` envelope from `--output-format json`
  - Claude `--output-format json` wraps the response in a `{"result": ...}` envelope — parse and unwrap it
  - If the output doesn't have a `result` field, fall back to returning the raw JSON
---
